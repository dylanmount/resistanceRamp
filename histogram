import matplotlib.pyplot as plt
import math
import numpy as np
import pyabf
from statistics import mean
import pandas as pd


from Ideal_trace_graph_formatting_version2 import abf_make_a_graph
from ideal_trace_same_bin_version2 import same_bin
from ideal_trace_combine_repeates_version2 import combine_repeates
from ideal_trace_calculate_mean_version2 import find_means
from ideal_trace_make_ideal_Y_list_version2 import make_ideal_Y
from low_pass_filter_abf_version1 import low_pass

#Global varables
#set the filter level
cutoff = 500 
bins_list = [90, 200, 300]



# manualy look at the graph and find values that are inbetween the levels
# Bins must be set such that there is at least 1 event in each bin. If any are empty, the code will not function







#####################################################################################
#######################################################################################
#######################################################################################



def set_level(abf_file):
# function to determin if two values are in the same bin
    global yes
    yes = 1
    global no
    no = 0
    # window_width= 59.999
    global window_width
    window_width = 10

    # the abf file
    global abf
    abf = pyabf.ABF(
        r"C:\Users\dcmou\Downloads\work\resistanceRamp\ion_data\23714000.abf"
    )
    global duration
    duration = abf.sweepLengthSec
   

    # do you want to just display the graph with just the filtered data and horizontal lines at bin juctions? (to check if the bin locations are appropriate) (yes/no)
    bins_check = no
    global time_step
    time_step = duration / len(abf.sweepY)
    abf.sweepY = -1.0 * abf.sweepY

    # low pass filter


    global filtered_sweepY
    filtered_sweepY = low_pass(abf.sweepY, abf.sweepX, cutoff, time_step)
    
    # filtered_sweepY = abf.sweepY  # turn off low pass filtering by adding this line and commenting out previous two

    if bins_check == 1:  # yes
        # plot the filtered data
        plt.plot(abf.sweepX, filtered_sweepY, linewidth=0.5)
        # create a list of x values, from 0 to duration (120 for abf files)
        x_values = []
        x = 0
        while x < duration:
            x_values.append(x)
            x = x + 1
        # runs through loop for for each bin junction
        bin_number = 0
        while bin_number < len(bins_list):
            y_values = []
            # creates a list of the y value for that junction that is the appropriate length
            y = 0
            while y < duration:
                y_values.append(bins_list[bin_number])
                y = y + 1
            # and plots it
            plt.plot(x_values, y_values, "k", linewidth=1)
            bin_number = bin_number + 1
        plt.axis([0, duration, -4, 4])
        plt.grid()
        plt.show()

    # defining lists
    level_list = []
    global level
    level = []
    global bin_index
    bin_index = []
    global bin_mean
    bin_mean = []
    global bin_length 
    bin_length = []
    bin_current = []
    # if it isn't checking the bin locations, then it does the rest of the program
    if bins_check == 0:  # no
        # v is the index location in the larger list, 0 through 600,000
        v = 0
        while v < len(filtered_sweepY):
            # print(v)
            # w is the bin number
            w = 1
            while w <= len(bins_list) and v < len(filtered_sweepY):
                # print(w)
                # runs loop if v less than the first bin junction (closed current), or if it is in bin w. If it is not, then w is increased by one and it tries again until the correct bin has been found
                while v < len(filtered_sweepY) and (
                    (filtered_sweepY[v] <= bins_list[0])
                    or (w == len(bins_list) and filtered_sweepY[v] >= bins_list[w - 1])
                    or (
                        filtered_sweepY[v] > bins_list[w - 1]
                        and filtered_sweepY[v] <= bins_list[w]
                    )
                ):
                    # when t equals 0 it indicates that the list for a certain level is not yet complete
                    t = 0
                    # creates a list (bin_current) of all the values in a row in the same bin
                    bin_current.append(filtered_sweepY[v])
                    v = v + 1
                    # if the value at location v is not in the same bin as the one at location v-1, then that is either the start of a new event or noise
                    # if the length of bin current is greater than (1/ cutoff* 1/time_step), then it follows this piece of code
                    if (
                        v == len(filtered_sweepY)
                        or len(bin_mean) == 0
                        or (
                            same_bin(filtered_sweepY[v], filtered_sweepY[v - 1], bins_list)
                            != True
                            and (
                                (
                                    same_bin(filtered_sweepY[v], bin_mean[-1], bins_list)
                                    == True
                                    and len(bin_current) >= (1 / cutoff) * (1 / time_step)
                                )
                                or same_bin(filtered_sweepY[v], bin_mean[-1], bins_list)
                                != True
                                and len(bin_current) >= 2 * (1 / cutoff) * (1 / time_step)
                            )
                        )
                        and t == 0
                    ):
                        # adds the length, mean, index, and level number of that section of code onto a list
                        bin_length.append(len(bin_current))
                        bin_mean.append(mean(bin_current))
                        bin_index.append(v - len(bin_current))
                        if filtered_sweepY[v - 1] <= bins_list[0]:
                            # print("appended 0 to level")
                            level.append(0)
                        if w < len(bins_list) and (
                            filtered_sweepY[v - 1] > bins_list[w - 1]
                            and filtered_sweepY[v - 1] <= bins_list[w]
                        ):
                            # print("appended w to level, version 1")
                            level.append(w)
                        if (
                            w == len(bins_list)
                            and filtered_sweepY[v - 1] >= bins_list[w - 1]
                        ):
                            # print("appended w to level, version 2")
                            level.append(w)
                        # t=1 indicates that the list for a level has been completed
                        t = 1

                    # runs this bit of code if there has been a transition that is less than ____ and after the event it returns to the same level (a simple noise spike)
                    if (
                        v < len(filtered_sweepY)
                        and (
                            (len(bin_current) < ((1 / cutoff) * (1 / time_step)))
                            and (
                                same_bin(
                                    filtered_sweepY[v], filtered_sweepY[v - 1], bins_list
                                )
                                != True
                            )
                            and (
                                same_bin(filtered_sweepY[v], bin_mean[-1], bins_list)
                                == True
                            )
                        )
                        and (t == 0)
                    ):
                        # adds the length and means from the last section to the length and mean from the most recent section (with weighting for the mean)
                        # then removes the previous values from the lists and adds the new ones instead
                        new_length = bin_length[-1] + len(bin_current)
                        bin_length.pop()
                        bin_length.append(new_length)
                        if len(bin_current) > 1:
                            mean_bin = mean(bin_current)
                        if len(bin_current) == 1:
                            mean_bin = bin_current[0]
                        new_mean = (
                            bin_mean[-1] * bin_length[-1] + mean_bin * len(bin_current)
                        ) / (bin_length[-1] + len(bin_current))
                        bin_mean.pop()
                        bin_mean.append(new_mean)
                        t = 1
                    # if the potential event is less than the decided length and the level before it is not the same as the level after it, then it follows this code
                    if (
                        v < len(filtered_sweepY)
                        and (
                            (len(bin_current) < (2 * (1 / cutoff) * (1 / time_step)))
                            and (
                                same_bin(
                                    filtered_sweepY[v], filtered_sweepY[v - 1], bins_list
                                )
                                != True
                            )
                        )
                        and (same_bin(filtered_sweepY[v], bin_mean[-1], bins_list) != True)
                        and (t == 0)
                    ):
                        # the are left in th list to be added to the next event
                        t = 0
                    # if t==1, then that list is completed and the mean and length are recorded, so it is cleared for the next event
                    if t == 1:
                        bin_current = []
                w = w + 1

        # this section of code checks for when the same level is recorded a few times in a row, then adds them together
        # it returns the mean, length, index, and levels lists as a list

        

        result = combine_repeates(bin_mean, bin_length, bin_index, level)
        bin_mean = result[0]
        bin_length = result[1]
        bin_index = result[2]
        level = result[3]

        # this finds the average length and weighted mean for each level
        

        result = find_means(bins_list, level, bin_mean, bin_length)
        global net_mean
        net_mean = result[0]
        avg_length = result[1]
    
    #####################################################################################
    ######################################################################################
    #######################################################################################
    #Histogram code 

def histogram(start,stop, location, cutoff):
    i=0
    while i < len(start):
        start_index= np.where(abf.sweepX == start[i])[0][0]
        stop_index = np.where(abf.sweepX == stop[i])[0][0]
        x=start_index
        while x<=stop_index:
            filtered_sweepY[x] = -1
            x+=1
        i+=1

            #create histogram 
    plt.hist(filtered_sweepY,bins=1000, range=(-10,600))
    plt.ylim(0, 1000)
    plt.title("file: " + location.split("\\")[-1].split(".")[0])
    plt.xlabel("Occurances with " + str(cutoff) + "Hz Filtering")
    plt.ylabel("pA")
    plt.show()


#########################################################################################
########################################################################################
####################################################################################



# old code 

#the location on your computer where you want the file and the name of the file

location= r"C:\Users\dcmou\Downloads\work\resistanceRamp\ion_data\23714000.xlsx"
set_level("string")


ideal_Y= make_ideal_Y(bin_length, net_mean, level)
abf_make_a_graph(window_width, ideal_Y, abf, filtered_sweepY, duration, bins_list)

#Allow the user to selet the data that they want to be deleted\
# large spike
spike_start = []
spike_stop = []

move_forward = input("Do you want to remove data? ")
while move_forward == "yes":
    spike_start.append(int(input("Enter starting value: ")))
    spike_stop.append(int(input("Enter ending value: ")))
    move_forward = input("Do you want to remove data? ")

#create a histogram with the delted data 
histogram(spike_start,spike_stop, location, cutoff)




# negative spike-- goes down from closed and does not change level
neg_spike_start = []
neg_spike_stop = []


# false_pos
false_pos_start = []
section_start = []
section_stop = []
# the level at the start of the section will be filled in for the whole range

# if yes, this will just display the idealized trace (without accounding for false positives) and the filtered data
# it then gives the option to change the scale in order to identify the locations of false positives
# if no, it runs the false positives, shows the graph and generates the excel file
find_false_values = no

ideal_Y= make_ideal_Y(bin_length, net_mean, level)

if find_false_values == 1:  # yes
    abf_make_a_graph(window_width, ideal_Y, abf, filtered_sweepY, duration, bins_list)
    # change_scale=input("change scale? (yes/no): ")
    change_scale = "yes"
    if change_scale == "yes":
        new_window_width = float(input("new window width: "))
        abf_make_a_graph(
            new_window_width, ideal_Y, abf, filtered_sweepY, duration, bins_list
        )

if find_false_values == 0:  # no
    # runs this code if there is a large noise spike
    d = 0
    e = 0
    while e < len(spike_start):
        false_index = 0
        v = round((spike_start[e] / time_step))
        while v < round(spike_stop[e] / time_step):
            c = 0
            # if the index is equal to any number in the bin_index, that means that there is a change of level there
            # while it is within the defined noise spike, that change of level is incorrect, and the value in the level list is replaced by -1
            while c < len(bin_index):
                if bin_index[c] == v:
                    false_index = c
                    level.pop(c)
                    level.insert(c, -1)
                    d = d + 1
                c = c + 1
            v = v + 1

        # the above process also replaces the level for the stretch of closed current after the spike with -1, when it should remain 0
        # the following couple lines of code find the last level changed to -1 in the spike and return it to 0, indicating a closed level
        c = 0
        while c < len(bin_index) - 1:
            if level[c] == -1 and level[c + 1] != -1:
                level.pop(c)
                level.insert(c, 0)
            c = c + 1
        e = e + 1

    # negative spike
    # a negative spike does not switch levels, however it would change the average value of the closed current
    # once a person identifies the start and stop location of the spike, this code disregards everything between those values
    e = 0
    while e < len(neg_spike_start):
        v = round((neg_spike_start[e] / time_step))
        c = 0
        while c < len(bin_index) - 1:
            # c is the position in the list of levels
            if v > bin_index[c] and v < bin_index[c + 1]:
                bin_index.insert(c + 1, round((neg_spike_start[e] / time_step)))
                bin_index.insert(c + 2, round(neg_spike_stop[e] / time_step))
                level.insert(c + 1, -1)
                level.insert(c + 2, 0)

                new_len_a = round((neg_spike_start[e] / time_step)) - bin_index[c]
                new_len_b = round(neg_spike_stop[e] / time_step) - round(
                    (neg_spike_start[e] / time_step)
                )
                new_len_c = bin_index[c + 3] - round(neg_spike_stop[e] / time_step)
                bin_length.pop(c)
                bin_length.insert(c, new_len_a)
                bin_length.insert(c + 1, new_len_b)
                bin_length.insert(c + 2, new_len_c)

                bin_mean.pop(c)
                bin_current = []
                a = bin_index[c]
                while a < bin_index[c + 1]:
                    bin_current.append(filtered_sweepY[a])
                    a = a + 1
                    if a == bin_index[c + 1]:
                        new_mean = mean(bin_current)
                        bin_mean.insert(c, new_mean)
                        bin_current = []
                while a < bin_index[c + 2]:
                    a = a + 1
                    if a == bin_index[c + 2]:
                        new_mean = bin_mean[c] - 0.5
                        bin_mean.insert(c + 1, new_mean)
                while a < bin_index[c + 3]:
                    bin_current.append(filtered_sweepY[a])
                    a = a + 1
                    if a == bin_index[c + 3]:
                        new_mean = mean(bin_current)
                        bin_mean.insert(c + 2, new_mean)
                        bin_current = []
            c = c + 1
        e = e + 1

    # false positives
    # e counts up from zero, it is the index of the starting location in the false_pos_start list, when e == len(false_pos_start), it will have completed dealing eith the false positives
    e = 0
    while e < len(false_pos_start):
        done = "no"
        v = round((false_pos_start[e]) / time_step)
        # starting at the index of the start time
        while v < (round((false_pos_start[e]) / time_step) + 5 / time_step) and v < len(
            abf.sweepY
        ):
            c = 0
            while c < len(bin_index):
                # if the index (v) equals any number in the bin_index, then that is the start or end of the false event
                if bin_index[c] == v and done == "no":
                    false_event = c
                    false_index = v
                    level.pop(false_event)
                    level.insert(false_event, level[false_event - 1])
                    # because there is just one event, once this code has been run once, done is changed to yes and it will not be run at the end of the event
                    done = "yes"
                c = c + 1
            v = v + 1
        e = e + 1
    e = 0
    while e < len(section_start):
        started = no
        v = round((section_start[e] / time_step))
        false_index = 0
        while v < round(section_stop[e] / time_step):
            c = 0
            # if the index is equal to any number in the bin_index, that means that there is a change of level there
            # while it is within the defined noise spike, that change of level is incorrect, and the value in the level list is replaced by -1
            while c < len(bin_index):
                if bin_index[c] == v:
                    if started == no:
                        correct_level = level[c - 1]
                    false_index = c
                    level.pop(c)
                    level.insert(c, correct_level)
                    started = yes
                if false_index == 0:
                    correct_level = c
                c = c + 1
            v = v + 1
        e = e + 1

    # removing false events creates more instances where several "events" in a row are the same event, at the same level, this calls the routine to combine those
    result = combine_repeates(bin_mean, bin_length, bin_index, level)
    # the rountine returns a list of results, the bin_mean, bin_length, bin_index, and level lists
    bin_mean = result[0]
    bin_length = result[1]
    bin_index = result[2]
    level = result[3]

   


    # and the ideal_Y list remade
    ideal_Y = make_ideal_Y(bin_length, net_mean, level)

    abf_make_a_graph(window_width, ideal_Y, abf, filtered_sweepY, duration, bins_list)

